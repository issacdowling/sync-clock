"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultPalette = exports.deviceSupportsMaterialYou = exports.getPaletteSync = exports.getPalette = exports.useMaterialYouService = exports.useMaterialYouPalette = exports.MaterialYouService = exports.useMaterialYou = void 0;
/* eslint-disable prettier/prettier */
const React = __importStar(require("react"));
const react_native_1 = require("react-native");
const constants_1 = require("./constants");
let RNMaterialYouModule;
try {
    RNMaterialYouModule = react_native_1.NativeModules?.RNMaterialYouModule;
}
catch (err) {
    console.error(err);
    RNMaterialYouModule = undefined;
}
/**
 * Hook to get the generated Material You colors.
 * @category React
 * @subcategory Hooks
 * @param {MaterialYouPalette} [fallbackPalette] The palette to use in case Material You is not supported.
 * @returns {MaterialYouPalette}
 */
const useMaterialYou = ({ fallbackPalette }) => {
    const stateRef = React.useRef(null);
    const initialPalette = RNMaterialYouModule?.initialPalette ?? cachedPalette ?? fallbackPalette ?? constants_1.DEFAULT_PALETTE;
    const [palette, setPalette] = React.useState(initialPalette);
    if (stateRef.current === null) {
        const _refresh = async () => {
            const _palette = await exports.getPalette();
            if (_palette && _palette.system_accent1 && _palette.system_accent2 && _palette.system_accent3 && _palette.system_neutral1 && _palette.system_neutral2) {
                setPalette(_palette);
                cachedPalette = _palette;
            }
            else {
                console.warn("Something went wrong while extracting Material You palette.");
            }
        };
        stateRef.current = {
            palette,
            isSupported: exports.deviceSupportsMaterialYou(),
            _refresh
        };
        stateRef.current._refresh();
    }
    stateRef.current.palette = palette;
    return stateRef.current;
};
exports.useMaterialYou = useMaterialYou;
/**
 * The context for the Material You API.
 */
const MaterialYouContext = React.createContext(null);
/**
 * React Context Provider for the Material You API.
 * - Makes sure Material You is supported on the device.
 * - Subscribes to palette regeneration.
 *
 * @param {MaterialYouPalette} [fallbackPalette] The palette to use in case Material You is not supported.
 */
const MaterialYouService = ({ children, fallbackPalette }) => {
    const materialYouApi = exports.useMaterialYou({ fallbackPalette });
    // Update color on app focus change.
    React.useEffect(() => {
        if (!materialYouApi.isSupported)
            return;
        const subscription = react_native_1.AppState.addEventListener('focus', () => {
            materialYouApi._refresh();
        });
        return () => {
            // @ts-ignore
            subscription.remove();
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    return <MaterialYouContext.Provider value={materialYouApi}>
        {children}
    </MaterialYouContext.Provider>;
};
exports.MaterialYouService = MaterialYouService;
/**
 * A hook that returns the current palette in current context.
 */
const useMaterialYouPalette = () => React.useContext(MaterialYouContext).palette;
exports.useMaterialYouPalette = useMaterialYouPalette;
/**
 * A hook that returns the current context.
 */
const useMaterialYouService = () => React.useContext(MaterialYouContext);
exports.useMaterialYouService = useMaterialYouService;
// ---
/**
 * Returns a promise with Material You palette generated from the devices wallpaper.
 */
const getPalette = async () => {
    try {
        const palette = await RNMaterialYouModule?.getMaterialYouPalettePromise();
        if (!palette)
            throw new Error("Material You is not supported on this device.");
        return { ...palette };
    }
    catch (err) {
        console.error(err);
        return getInitialPalette();
    }
};
exports.getPalette = getPalette;
/**
 * Returns the Material You palette generated at runtime from the device wallpaper.
 */
const getPaletteSync = () => {
    try {
        const palette = getInitialPalette();
        if (!palette)
            throw new Error("Material You is not supported on this device.");
        return { ...palette };
    }
    catch (err) {
        console.error(err);
        return null;
    }
};
exports.getPaletteSync = getPaletteSync;
// ---
/**
 * Returns true, if the device is running Android 12/has the generated color palette.
 * @returns {Boolean}
 */
const deviceSupportsMaterialYou = () => RNMaterialYouModule?.isSupported ?? false;
exports.deviceSupportsMaterialYou = deviceSupportsMaterialYou;
// Chaching the palette to avoid flicker when the palette changes and provice a fallback. 
// Might be stupid, let me know if you have objections.
let cachedPalette = null;
/**
 * Returns the initial palette.
 */
const getInitialPalette = () => RNMaterialYouModule?.initialPalette ?? cachedPalette ?? constants_1.DEFAULT_PALETTE;
exports.defaultPalette = constants_1.DEFAULT_PALETTE;
//# sourceMappingURL=index.js.map